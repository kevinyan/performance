{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/index.js","webpack:///./util/lib.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","_lib","urlList","onload","img","element","callback","ie","window","attachEvent","opera","done","fn","onerror","isHidden","isInFirstScreen","timer","setInterval","clearInterval","readyState","firstScreenEndTime","Date","onloadCallback","thisEndTime","setTimeout","imgList","document","getElementsByTagName","length","url","getAttribute","isCache","push","getTagImgList","styleList","len","tagName","background","getCurrentStyle","indexOf","split","replace","getStyleImgList","tempList","temp","getUniqueList","Image","src","bindImgOnload","console","log","domReadyEndTime","documentElement","doScroll","err","arguments","callee","onreadystatechange","addEventListener","sendData","data","type","pageId","whiteScreenTime","whiteScreenEndTime","startTime","firstScreenTime","domReadyTime","onloadTime","onloadEndTime","addEvent","style","currentStyle","div","getComputedStyle","display","visibility","width","offsetWidth","height","offsetHeight","client","getBoundingClientRect","left","clientWidth","body","top","clientHeight"],"mappings":"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","file":"app.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import {\n    getCurrentStyle,\n    isHidden,\n    isInFirstScreen,\n    isCache,\n    addEvent\n} from '../util/lib';\n\n\n/***\n获取首屏时间\n**/\nlet urlList = [];\n//收集img标签中的图片url\nlet getTagImgList = () => {\n    let imgList = document.getElementsByTagName('img');\n    for (let i = 0; i < imgList.length; i++) {\n        let img = imgList[i];\n        let url = img.getAttribute('src');\n        //判断是否隐藏、是否在首屏、是否为非缓存\n        if (!isCache(url)) {\n            urlList.push({ element: img, url: url });\n        }\n    }\n}\n//收集背景样式中的图片url\nlet getStyleImgList = () => {\n    let styleList = document.getElementsByTagName('*');\n    for (let i = 0, len = styleList.length; i < len; i++) {\n        let element = styleList[i];\n        //第一步判断是否隐藏及是否为图片，因为有判断专门为img的逻辑，这一步可以过滤掉大部分不相干的元素\n        if (element.tagName !== 'IMG' && !isHidden(element)) {\n            //取得元素的最终样式，避免获取覆盖的样式\n            let background = getCurrentStyle(element, 'backgroundImage');\n            //第二步判断是否设置了背景图片及是否在首屏\n            if (background && background.indexOf('url') !== -1 && isInFirstScreen(element)) {\n                //提取出纯净的url地址\n                let url = background.split(/\\(|\\)/g)[1];\n                //ie两边会把双引号给带上\n                url = url.replace(/\\\"+/g, '');\n                urlList.push({ element: element, url: url });\n            }\n        }\n    }\n}\n\n\n//url去重处理\nlet getUniqueList = () => {\n    let tempList = [];\n    let temp = {};\n    for (let i = 0, len = urlList.length; i < len; i++) {\n        let url = urlList[i];\n        if (!temp[url.url]) {\n            temp[url.url] = true;\n            tempList.push(url);\n        }\n    }\n    urlList = tempList;\n}\n\n\n\n//绑定onload事件\nlet onload = (img, element, callback) => {\n    //判读是否为IE\n    let ie = !!(window.attachEvent && !window.opera);\n    let done = false;\n    let fn = function () {\n        //有可能发生重复响应onload的情况，所以这个地方标识一下\n        if (!done) {\n            done = true;\n            //清理一下内存\n            img = img.onload = img.onerror = null;\n            //图片加载完毕判断是否隐藏，及是否在首屏\n            if (!isHidden(element) && isInFirstScreen(element)) {\n                callback && callback();\n            }\n        }\n    };\n    //图片加载失败的情况也需要监听\n    img.onload = img.onerror = function () {\n        fn();\n    };\n    //有的ie浏览器在缓存存在的情况可能不会响应onload事件，所以需要定时监听readyState状态\n    if (ie) {\n        //设置一个定时器，不断判断readyState状态\n        let timer = window.setInterval(function () {\n            //如果已经执行过回调了，则无需在继续心跳\n            if (done) {\n                timer && window.clearInterval(timer);\n                return;\n            }\n            //readyState为loaded或者comlete时代表加载完毕\n            if (img.readyState === 'loaded' || img.readyState === 'complete') {\n                timer && window.clearInterval(timer);\n                fn();\n            }\n        }, 10);\n    }\n}\n//给所有url创建Image对象，并绑定onload事件\nlet bindImgOnload = () => {\n    for (let i = 0, len = urlList.length; i < len; i++) {\n        let url = urlList[i];\n        let img = new Image();\n        //onload需要在赋值src之前，不然加载快的图片可能会在onload绑定上之前加载完毕。\n        onload(img, url.element, onloadCallback);\n        img.src = url.url;\n    }\n}\n\n\n//onload事件回调\nlet firstScreenEndTime = +new Date();\n\nlet onloadCallback = () => {\n    let thisEndTime = +new Date();\n    //每次都做对比，直到找出最慢的一张\n    if (thisEndTime > firstScreenEndTime) {\n        firstScreenEndTime = thisEndTime;\n    }\n};\n\n// 定时启动\nsetTimeout(() => {\n    getTagImgList();\n    getStyleImgList();\n    getUniqueList();\n    bindImgOnload();\n    console.log(urlList)\n}, 300)\n\n\n\n\nlet domReadyEndTime = +new Date();\n//绑定domready事件\nlet bindDomReadyEvent = () => {\n    let done = false;\n    let ie = !!(window.attachEvent && !window.opera);\n    let fn = function () {\n        //同样domready有可能重复响应，所以需要判断一下\n        if (!done) {\n            done = true;\n            domReadyEndTime = +new Date();\n        }\n    };\n    if (ie) {\n        //由于ie不支持DOMContentLoaded事件，因此采用不断执行doScroll的方式，\n        //因为在ie中只有页面domready之后才会成功执行doScroll方法\n        (function () {\n            try {\n                document.documentElement.doScroll('left');\n            } catch (err) {\n                //在domready之前执行doScroll会报错，在这里捕获异常之后继续执行doScroll\n                setTimeout(arguments.callee, 0);\n                return;\n            }\n            //没有异常发生时就可以执行回调了\n            fn();\n        })();\n        //如果实在不执行doScroll，有的时候页面加载很快的时候，就直接在onload事件中去执行回调\n        document.onreadystatechange = function () {\n            if (document.readyState === 'complete') {\n                document.onreadystatechange = null;\n                fn();\n            }\n        };\n    } else {\n        //非IE浏览器直接监听DOMContentLoaded事件\n        document.addEventListener('DOMContentLoaded', function () {\n            fn();\n        }, false);\n    }\n}\nbindDomReadyEvent();\n\n\n\n//发送数据\nlet sendData = () => {\n    //需要发送的数据\n    let data = {\n        //统计类型\n        type: 'performance',\n        //页面id\n        pageId: window.pageId || 'defualt',\n        //白屏时间\n        whiteScreenTime: whiteScreenEndTime - startTime,\n        //首屏时间 有时候首屏取不到图片，就取domReady时间\n        firstScreenTime: (firstScreenEndTime || domReadyEndTime) - startTime,\n        //用户可操作时间\n        domReadyTime: domReadyEndTime - startTime,\n        //页面总下载时间\n        onloadTime: onloadEndTime - startTime\n    };\n\n    console.log(data);\n}\n\n\nlet onloadEndTime = +new Date();\n//有可能此时页面已经加载完毕。\nif (document.readyState === 'complete') {\n    sendData();\n} else {\n    addEvent(window, 'load', function () {\n        onloadEndTime = +new Date();\n        sendData();\n    });\n}","// 获取当前dom元素的CSS属性\nlet a = '12312';\n\nlet getCurrentStyle = (element, style) => {\n    let newstyle = '';\n    if (element.currentStyle) {\n        //IE上兼容\n        newstyle = div.currentStyle[style];\n    } else {\n        //火狐谷歌上兼容\n        newstyle = window.getComputedStyle(element, null)[style]\n    }\n    return newstyle;\n}\n\n\n//判断是否隐藏\nlet isHidden = element => {\n    //获取元素最终样式\n    let display = getCurrentStyle(element, 'display');\n    let visibility = getCurrentStyle(element, 'visibility');\n    //获取元素宽高\n    let width = element.offsetWidth;\n    let height = element.offsetHeight;\n    //对于绝对隐藏、相对隐藏、宽高为0的元素可以认为是不需要在首屏展示的\n    return display === 'none' ||\n        visibility === 'hidden' ||\n        width === 0 ||\n        height === 0;\n}\n\n//判断是否在首屏\nlet isInFirstScreen = element => {\n\n    //获取元素距离浏览器可视区域的相对距离\n    let client = element.getBoundingClientRect();\n    return client.left >= 0 &&\n        client.left < (document.documentElement.clientWidth || document.body.clientWidth) &&\n        client.top >= 0 &&\n        client.top < (document.documentElement.clientHeight || document.body.clientHeight);\n}\n\n\n\n//判读是否为非缓存图片\nlet isCache = url => {\n    //排除掉一些无法缓存的图片，比如验证码,不带src属性的占位图片等\n    return !url || url.indexOf('?') !== -1;\n}\n\n\n//兼容浏览器的事件监听函数\nlet addEvent = (element, type, callback) => {\n\n    if (element.addEventListener) {\n        element.addEventListener(type, callback, false);\n    } else if (element.attachEvent) {\n        element.attachEvent('on' + type, callback);\n    } else {\n        element['on' + type] = callback;\n    }\n}\n\n\nexport {\n    getCurrentStyle,\n    isHidden,\n    isInFirstScreen,\n    isCache,\n    addEvent\n}"],"sourceRoot":""}